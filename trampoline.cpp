#include <stdio.h>
#include <string.h>

#include <vector>
#include <string>
#include <sstream>
#include <fstream>
#include <algorithm>

class ParsedFunction
{
	using String = std::string;
	using StringPack = std::vector< String >;
public:
	String 		aName;
        StringPack 	aParams;
        String 		aDllName;
        String 		aReturn;
};

static const char *pSourceFile = 0;

static std::vector< ParsedFunction >   gFunctionData;

void skip_ws( const char *spBuffer, unsigned int *pPtr )
{
	for ( ; spBuffer[ *pPtr ] <= ' '; ++*pPtr );
}

char *parse_string( char *spBuffer, unsigned int *pPtr, char sTerminator )
{
	char *pStr = spBuffer + *pPtr;
	for ( ; spBuffer[ *pPtr ] <= 'z' && spBuffer[ *pPtr ] != ',' && spBuffer[ *pPtr ] != ')'; ++*pPtr );
	spBuffer[ *pPtr ] = 0;
	++pPtr;
	return pStr;
}

std::string remove_space( std::string sStr )
{
	sStr.erase( std::remove( sStr.begin(  ), sStr.end(  ), ' ' ), sStr.end(  ) );
	return sStr;
}

ParsedFunction tokenize_string( std::string& sStr, char *spDllName )
{
	ParsedFunction f{  };

	std::vector< std::string > tokens;
	std::stringstream          check( sStr );
	std::string                intermediate;

        while ( std::getline( check, intermediate, ',' ) )
		tokens.push_back( intermediate );

	f.aReturn  = tokens[ 0 ];
	f.aName    = remove_space( tokens[ 1 ] );
	f.aDllName = spDllName;
	for ( int i = 0; i < tokens.size(  ) - 2; ++i )
		f.aParams.push_back( tokens[ i + 2 ] );

	return f;
}

void parse_dll_funcs( char *spSource, unsigned int *spPtr, char *spDllName )
{
	skip_ws( spSource, spPtr );
	for ( ; spSource[ *spPtr ]; ++*spPtr )
	{
		if ( spSource[ *spPtr ] == 'D' )
		{
			if ( strncmp( spSource + *spPtr, "DLLFUNC", 7 ) == 0 )
			{
				*spPtr += 8;
				std::string funcBody = "";
				for ( ; spSource[ *spPtr ] != ')'; ++*spPtr ) funcBody += spSource[ *spPtr ];
				++*spPtr;
				gFunctionData.push_back( tokenize_string( funcBody, spDllName ) );
			}
		}
		/* End of DLLEXPORT.  */
		if ( spSource[ *spPtr ] == ')' )
			return;
	}
}

void parse_source( char *sSource, unsigned int sLen )
{
	unsigned int p = 0;
	char *pCurrentLibrary = 0;
	for ( ; p < sLen && sSource[ p ]; ++p )
	{
		if ( sSource[ p ] == 'D' )
		{
			if ( strncmp( sSource + p, "DLLOPEN", 7 ) == 0 )
			{
				p += 8;
				skip_ws( sSource, &p );
				pCurrentLibrary = sSource + p;
				for ( ; sSource[ p ] >= 'A' && sSource[ p ] <= 'z'; ++p );
				sSource[ p ] = 0;
				skip_ws( sSource, &p );
				++p;
				parse_dll_funcs( sSource, &p, pCurrentLibrary );
			}
		}
	}
}

void print_functions(  )
{
	for ( const auto &rFcn : gFunctionData )
	{
		printf( "DLL: %s\n", rFcn.aDllName.c_str(  ) );
		printf( "Name: %s\n", rFcn.aName.c_str(  ) );
		printf( "Returns: %s\n", rFcn.aReturn.c_str(  ) );
		printf( "Parameters: { " );
		for ( const auto& param : rFcn.aParams )
			printf( "%s, ", param.c_str(  ) );
		printf( "}\n\n" );
	}
}

void construct_c_source( const char *spOut )
{
	std::ofstream o;
	o.open( spOut );
	o << "/*\n";
	o << " * THIS FILE HAS BEEN AUTOGENERATED FOR USE BY " << pSourceFile << std::endl;
	o << " *\n";
	o << " * PLEASE DO NOT TOUCH, THINGS MAY NOT WORK AS INTENDED\n";
	o << " */\n";
	o << "#include <dlfcn.h>\n";
	o << "#include <stdio.h>\n\n";
	std::vector< std::string > dlls;
        for ( const auto& rFcn : gFunctionData )
	        dlls.push_back( rFcn.aDllName );

	std::sort( dlls.begin(  ), dlls.end(  ) );
	dlls.erase( std::unique( dlls.begin(  ), dlls.end(  ) ), dlls.end(  ) );
	for ( const auto& rDll : dlls )
	{
		o << "/* REQUIRED FOR " << rDll << ".so FUNCTIONS  */\n";
		o << "void *p" << rDll << "Ptrs[ 128 ];\n";
	}
	o << "\n#define FUNC( p, i )           \\\n";
	o << "void ( *func )(  );            \\\n";
	o << "*( void** )( &func ) = p[ i ]; \\\n";
	o << "func(  );\n";
	for ( const auto& rDll : dlls )
	{
		o << "/* GENERATE " << rDll << ".so SHIMS  */\n";
		o << "int init_" << rDll << "_shims(  )\n";
		o << "{\n";
		o << "\tvoid *p = dlopen( \"bin/" << rDll << ".so\", RTLD_LAZY );\n";
		o << "\tif ( !p )\n";
		o << "\t\t return fprintf( stderr, \"FATAL SHIM INIT ERROR: %s\\n\", dlerror(  ) );\n\n";
		unsigned int i = 0;
	        for ( const auto& rFcn : gFunctionData )
		{
			if ( rFcn.aDllName == rDll )
			{
				o << "\tp" << rDll << "Ptrs[ " << i++ << " ] = dlsym( p, \"" << rFcn.aName << "\" );\n";
			}
		}
		o << "\n\treturn 0;\n";
		o << "}\n\n";
	}
        o << "extern \"C\"\n";
	o << "{\n";
	unsigned int i;
	std::string currentDll = "";
	for ( const auto& rFcn : gFunctionData )
	{
		/* Classic pitfall to basic computational iteration, smh.  */
	        if ( ( currentDll != rFcn.aDllName ) || currentDll == "" )
			i = 0;
		
		//o << "\t" << rFcn.aReturn << ' ' << rFcn.aName << "(  ){ " << " FUNC( p" << rFcn.aDllName << "Ptrs, " << i++ << " ) }\n\n";
		o << "\t" << rFcn.aReturn << ' ' << rFcn.aName << "( ";
		unsigned int j = 0;
		for ( const auto& rParam : rFcn.aParams )
		{
			if ( j != rFcn.aParams.size(  ) - 1 )
				o << rParam + " p" << j++ << ", ";
			else
				o << rParam + " p" << j++;
		}

		o << " )\n\t{\n";
		o << "\t\t" << rFcn.aReturn << " ( *func )( ";
		j = 0;
		for ( const auto& rParam : rFcn.aParams )
		{
			if ( j != rFcn.aParams.size(  ) - 1 )
				o << rParam + ", ";
			else
				o << rParam;
			++j;
		}
		o << " );\n";
		o << "\t\t*( void** )( &func ) = p" + rFcn.aDllName + "Ptrs[ " << i++ << " ];\n";
		o << "\t\tfunc( ";
		j = 0;
		for ( const auto& rParam : rFcn.aParams )
			if ( j != rFcn.aParams.size(  ) - 1 )
				o << "p" << j++ << ", ";
			else
				o << "p" << j++;
		o << " );\n";
		o << "\t}\n";
		currentDll = rFcn.aDllName;
	}
	o << "}\n";

	o.close(  );

	printf( "Succesfully wrote to %s\n", spOut );
}

int main( const int argc, const char **argv )
{
	for ( int i = 0; i < argc; ++i )
	{
		if ( argc < 3 )
			return fprintf( stderr, "FATAL: No input file specified. Exiting...\n" );
		
		if ( strncmp( argv[ i ], "-i", 2 ) == 0 )
			pSourceFile = argv[ i + 1 ];
	}
        FILE *pFile = fopen( pSourceFile, "rb" );
	//FILE *pFile = fopen( "/home/karl/Desktop/Git-Repos/crosslight_bk/src/core/game_entry.cpp", "rb" );
	if ( !pFile )
		return fprintf( stderr, "FATAL: file %s does not exist! Exiting...\n", pSourceFile );
	
	fseek( pFile, 0, SEEK_END );
	unsigned int fileLen = ftell( pFile );
	char *pBuffer = ( char* )malloc( fileLen );
	rewind( pFile );
	fread( pBuffer, fileLen, 1, pFile );
	fclose( pFile );

	parse_source( pBuffer, fileLen );

	size_t index = std::string( pSourceFile ).find_last_of( "." );
	std::string outFile = std::string( pSourceFile ).substr( 0, index ) + "_shims.cpp";

	construct_c_source( outFile.c_str(  ) );
}
