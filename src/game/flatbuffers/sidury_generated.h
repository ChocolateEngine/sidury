// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SIDURY_H_
#define FLATBUFFERS_GENERATED_SIDURY_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

struct Vec2;

struct Vec3;

struct Vec4;

struct NetMsg_UserCmd;
struct NetMsg_UserCmdBuilder;

struct NetMsg_ServerInfo;
struct NetMsg_ServerInfoBuilder;

struct NetMsg_ClientInfo;
struct NetMsg_ClientInfoBuilder;

struct NetMsg_ServerClientInfo;
struct NetMsg_ServerClientInfoBuilder;

struct NetMsg_ServerConnectResponse;
struct NetMsg_ServerConnectResponseBuilder;

struct NetMsg_ClientConnect;
struct NetMsg_ClientConnectBuilder;

struct NetMsg_Disconnect;
struct NetMsg_DisconnectBuilder;

struct NetMsg_ConVar;
struct NetMsg_ConVarBuilder;

struct NetMsg_Paused;
struct NetMsg_PausedBuilder;

struct MsgSrc_Client;
struct MsgSrc_ClientBuilder;

struct MsgSrc_Server;
struct MsgSrc_ServerBuilder;

struct NetMsg_ComponentUpdateData;
struct NetMsg_ComponentUpdateDataBuilder;

struct NetMsg_ComponentUpdate;
struct NetMsg_ComponentUpdateBuilder;

struct NetMsg_EntityUpdate;
struct NetMsg_EntityUpdateBuilder;

struct NetMsg_EntityUpdates;
struct NetMsg_EntityUpdatesBuilder;

struct NetMsg_ComponentUpdates;
struct NetMsg_ComponentUpdatesBuilder;

struct NetComp_Transform;
struct NetComp_TransformBuilder;

struct NetComp_TransformSmall;
struct NetComp_TransformSmallBuilder;

struct NetComp_RigidBody;
struct NetComp_RigidBodyBuilder;

struct NetComp_Direction;
struct NetComp_DirectionBuilder;

struct NetComp_Gravity;
struct NetComp_GravityBuilder;

struct NetComp_Camera;
struct NetComp_CameraBuilder;

struct NetComp_ModelInfo;
struct NetComp_ModelInfoBuilder;

struct NetComp_Light;
struct NetComp_LightBuilder;

struct NetComp_PlayerMoveData;
struct NetComp_PlayerMoveDataBuilder;

struct NetComp_PlayerZoom;
struct NetComp_PlayerZoomBuilder;

enum ESiduryProtocolVer : uint16_t {
  ESiduryProtocolVer_Value = 3,
  ESiduryProtocolVer_MIN = ESiduryProtocolVer_Value,
  ESiduryProtocolVer_MAX = ESiduryProtocolVer_Value
};

inline const ESiduryProtocolVer (&EnumValuesESiduryProtocolVer())[1] {
  static const ESiduryProtocolVer values[] = {
    ESiduryProtocolVer_Value
  };
  return values;
}

inline const char * const *EnumNamesESiduryProtocolVer() {
  static const char * const names[2] = {
    "Value",
    nullptr
  };
  return names;
}

inline const char *EnumNameESiduryProtocolVer(ESiduryProtocolVer e) {
  if (::flatbuffers::IsOutRange(e, ESiduryProtocolVer_Value, ESiduryProtocolVer_Value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(ESiduryProtocolVer_Value);
  return EnumNamesESiduryProtocolVer()[index];
}

enum EPlayerMoveType : int8_t {
  EPlayerMoveType_Walk = 0,
  EPlayerMoveType_NoClip = 1,
  EPlayerMoveType_Fly = 2,
  EPlayerMoveType_MIN = EPlayerMoveType_Walk,
  EPlayerMoveType_MAX = EPlayerMoveType_Fly
};

inline const EPlayerMoveType (&EnumValuesEPlayerMoveType())[3] {
  static const EPlayerMoveType values[] = {
    EPlayerMoveType_Walk,
    EPlayerMoveType_NoClip,
    EPlayerMoveType_Fly
  };
  return values;
}

inline const char * const *EnumNamesEPlayerMoveType() {
  static const char * const names[4] = {
    "Walk",
    "NoClip",
    "Fly",
    nullptr
  };
  return names;
}

inline const char *EnumNameEPlayerMoveType(EPlayerMoveType e) {
  if (::flatbuffers::IsOutRange(e, EPlayerMoveType_Walk, EPlayerMoveType_Fly)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEPlayerMoveType()[index];
}

enum EMsgSrc_Client : uint8_t {
  EMsgSrc_Client_Invalid = 0,
  EMsgSrc_Client_Disconnect = 1,
  EMsgSrc_Client_ConVar = 2,
  EMsgSrc_Client_ClientInfo = 3,
  EMsgSrc_Client_ConnectFinish = 4,
  EMsgSrc_Client_UserCmd = 5,
  EMsgSrc_Client_FullUpdate = 6,
  EMsgSrc_Client_MIN = EMsgSrc_Client_Invalid,
  EMsgSrc_Client_MAX = EMsgSrc_Client_FullUpdate
};

inline const EMsgSrc_Client (&EnumValuesEMsgSrc_Client())[7] {
  static const EMsgSrc_Client values[] = {
    EMsgSrc_Client_Invalid,
    EMsgSrc_Client_Disconnect,
    EMsgSrc_Client_ConVar,
    EMsgSrc_Client_ClientInfo,
    EMsgSrc_Client_ConnectFinish,
    EMsgSrc_Client_UserCmd,
    EMsgSrc_Client_FullUpdate
  };
  return values;
}

inline const char * const *EnumNamesEMsgSrc_Client() {
  static const char * const names[8] = {
    "Invalid",
    "Disconnect",
    "ConVar",
    "ClientInfo",
    "ConnectFinish",
    "UserCmd",
    "FullUpdate",
    nullptr
  };
  return names;
}

inline const char *EnumNameEMsgSrc_Client(EMsgSrc_Client e) {
  if (::flatbuffers::IsOutRange(e, EMsgSrc_Client_Invalid, EMsgSrc_Client_FullUpdate)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEMsgSrc_Client()[index];
}

enum EMsgSrc_Server : uint8_t {
  EMsgSrc_Server_Invalid = 0,
  EMsgSrc_Server_Disconnect = 1,
  EMsgSrc_Server_ConVar = 2,
  EMsgSrc_Server_ClientInfo = 3,
  EMsgSrc_Server_ConnectResponse = 4,
  EMsgSrc_Server_ServerInfo = 5,
  EMsgSrc_Server_ComponentRegistryInfo = 6,
  EMsgSrc_Server_ComponentList = 7,
  EMsgSrc_Server_EntityList = 8,
  EMsgSrc_Server_Paused = 9,
  EMsgSrc_Server_MIN = EMsgSrc_Server_Invalid,
  EMsgSrc_Server_MAX = EMsgSrc_Server_Paused
};

inline const EMsgSrc_Server (&EnumValuesEMsgSrc_Server())[10] {
  static const EMsgSrc_Server values[] = {
    EMsgSrc_Server_Invalid,
    EMsgSrc_Server_Disconnect,
    EMsgSrc_Server_ConVar,
    EMsgSrc_Server_ClientInfo,
    EMsgSrc_Server_ConnectResponse,
    EMsgSrc_Server_ServerInfo,
    EMsgSrc_Server_ComponentRegistryInfo,
    EMsgSrc_Server_ComponentList,
    EMsgSrc_Server_EntityList,
    EMsgSrc_Server_Paused
  };
  return values;
}

inline const char * const *EnumNamesEMsgSrc_Server() {
  static const char * const names[11] = {
    "Invalid",
    "Disconnect",
    "ConVar",
    "ClientInfo",
    "ConnectResponse",
    "ServerInfo",
    "ComponentRegistryInfo",
    "ComponentList",
    "EntityList",
    "Paused",
    nullptr
  };
  return names;
}

inline const char *EnumNameEMsgSrc_Server(EMsgSrc_Server e) {
  if (::flatbuffers::IsOutRange(e, EMsgSrc_Server_Invalid, EMsgSrc_Server_Paused)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEMsgSrc_Server()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  Vec2()
      : x_(0),
        y_(0) {
  }
  Vec2(float _x, float _y)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Vec2, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vec3()
      : x_(0),
        y_(0),
        z_(0) {
  }
  Vec3(float _x, float _y, float _z)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)),
        z_(::flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return ::flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Vec3, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec4 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  Vec4()
      : x_(0),
        y_(0),
        z_(0),
        w_(0) {
  }
  Vec4(float _x, float _y, float _z, float _w)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)),
        z_(::flatbuffers::EndianScalar(_z)),
        w_(::flatbuffers::EndianScalar(_w)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return ::flatbuffers::EndianScalar(z_);
  }
  float w() const {
    return ::flatbuffers::EndianScalar(w_);
  }
};
FLATBUFFERS_STRUCT_END(Vec4, 16);

struct NetMsg_UserCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NetMsg_UserCmdBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ANGLES = 4,
    VT_BUTTONS = 6,
    VT_MOVE_TYPE = 8,
    VT_FLASHLIGHT = 10
  };
  const Vec3 *angles() const {
    return GetStruct<const Vec3 *>(VT_ANGLES);
  }
  int32_t buttons() const {
    return GetField<int32_t>(VT_BUTTONS, 0);
  }
  EPlayerMoveType move_type() const {
    return static_cast<EPlayerMoveType>(GetField<int8_t>(VT_MOVE_TYPE, 0));
  }
  bool flashlight() const {
    return GetField<uint8_t>(VT_FLASHLIGHT, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Vec3>(verifier, VT_ANGLES, 4) &&
           VerifyField<int32_t>(verifier, VT_BUTTONS, 4) &&
           VerifyField<int8_t>(verifier, VT_MOVE_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_FLASHLIGHT, 1) &&
           verifier.EndTable();
  }
};

struct NetMsg_UserCmdBuilder {
  typedef NetMsg_UserCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_angles(const Vec3 *angles) {
    fbb_.AddStruct(NetMsg_UserCmd::VT_ANGLES, angles);
  }
  void add_buttons(int32_t buttons) {
    fbb_.AddElement<int32_t>(NetMsg_UserCmd::VT_BUTTONS, buttons, 0);
  }
  void add_move_type(EPlayerMoveType move_type) {
    fbb_.AddElement<int8_t>(NetMsg_UserCmd::VT_MOVE_TYPE, static_cast<int8_t>(move_type), 0);
  }
  void add_flashlight(bool flashlight) {
    fbb_.AddElement<uint8_t>(NetMsg_UserCmd::VT_FLASHLIGHT, static_cast<uint8_t>(flashlight), 0);
  }
  explicit NetMsg_UserCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NetMsg_UserCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NetMsg_UserCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NetMsg_UserCmd> CreateNetMsg_UserCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const Vec3 *angles = nullptr,
    int32_t buttons = 0,
    EPlayerMoveType move_type = EPlayerMoveType_Walk,
    bool flashlight = false) {
  NetMsg_UserCmdBuilder builder_(_fbb);
  builder_.add_buttons(buttons);
  builder_.add_angles(angles);
  builder_.add_flashlight(flashlight);
  builder_.add_move_type(move_type);
  return builder_.Finish();
}

struct NetMsg_ServerInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NetMsg_ServerInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_CLIENT_COUNT = 6,
    VT_MAX_CLIENTS = 8,
    VT_MAP_NAME = 10
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  uint8_t client_count() const {
    return GetField<uint8_t>(VT_CLIENT_COUNT, 0);
  }
  uint8_t max_clients() const {
    return GetField<uint8_t>(VT_MAX_CLIENTS, 0);
  }
  const ::flatbuffers::String *map_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MAP_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_CLIENT_COUNT, 1) &&
           VerifyField<uint8_t>(verifier, VT_MAX_CLIENTS, 1) &&
           VerifyOffset(verifier, VT_MAP_NAME) &&
           verifier.VerifyString(map_name()) &&
           verifier.EndTable();
  }
};

struct NetMsg_ServerInfoBuilder {
  typedef NetMsg_ServerInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(NetMsg_ServerInfo::VT_NAME, name);
  }
  void add_client_count(uint8_t client_count) {
    fbb_.AddElement<uint8_t>(NetMsg_ServerInfo::VT_CLIENT_COUNT, client_count, 0);
  }
  void add_max_clients(uint8_t max_clients) {
    fbb_.AddElement<uint8_t>(NetMsg_ServerInfo::VT_MAX_CLIENTS, max_clients, 0);
  }
  void add_map_name(::flatbuffers::Offset<::flatbuffers::String> map_name) {
    fbb_.AddOffset(NetMsg_ServerInfo::VT_MAP_NAME, map_name);
  }
  explicit NetMsg_ServerInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NetMsg_ServerInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NetMsg_ServerInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NetMsg_ServerInfo> CreateNetMsg_ServerInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    uint8_t client_count = 0,
    uint8_t max_clients = 0,
    ::flatbuffers::Offset<::flatbuffers::String> map_name = 0) {
  NetMsg_ServerInfoBuilder builder_(_fbb);
  builder_.add_map_name(map_name);
  builder_.add_name(name);
  builder_.add_max_clients(max_clients);
  builder_.add_client_count(client_count);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NetMsg_ServerInfo> CreateNetMsg_ServerInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint8_t client_count = 0,
    uint8_t max_clients = 0,
    const char *map_name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto map_name__ = map_name ? _fbb.CreateString(map_name) : 0;
  return CreateNetMsg_ServerInfo(
      _fbb,
      name__,
      client_count,
      max_clients,
      map_name__);
}

struct NetMsg_ClientInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NetMsg_ClientInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_STEAM_ID = 6
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  uint64_t steam_id() const {
    return GetField<uint64_t>(VT_STEAM_ID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint64_t>(verifier, VT_STEAM_ID, 8) &&
           verifier.EndTable();
  }
};

struct NetMsg_ClientInfoBuilder {
  typedef NetMsg_ClientInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(NetMsg_ClientInfo::VT_NAME, name);
  }
  void add_steam_id(uint64_t steam_id) {
    fbb_.AddElement<uint64_t>(NetMsg_ClientInfo::VT_STEAM_ID, steam_id, 0);
  }
  explicit NetMsg_ClientInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NetMsg_ClientInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NetMsg_ClientInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NetMsg_ClientInfo> CreateNetMsg_ClientInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    uint64_t steam_id = 0) {
  NetMsg_ClientInfoBuilder builder_(_fbb);
  builder_.add_steam_id(steam_id);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NetMsg_ClientInfo> CreateNetMsg_ClientInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint64_t steam_id = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return CreateNetMsg_ClientInfo(
      _fbb,
      name__,
      steam_id);
}

struct NetMsg_ServerClientInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NetMsg_ServerClientInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_STEAM_ID = 6,
    VT_ENTITY_ID = 8
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  uint64_t steam_id() const {
    return GetField<uint64_t>(VT_STEAM_ID, 0);
  }
  uint64_t entity_id() const {
    return GetField<uint64_t>(VT_ENTITY_ID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint64_t>(verifier, VT_STEAM_ID, 8) &&
           VerifyField<uint64_t>(verifier, VT_ENTITY_ID, 8) &&
           verifier.EndTable();
  }
};

struct NetMsg_ServerClientInfoBuilder {
  typedef NetMsg_ServerClientInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(NetMsg_ServerClientInfo::VT_NAME, name);
  }
  void add_steam_id(uint64_t steam_id) {
    fbb_.AddElement<uint64_t>(NetMsg_ServerClientInfo::VT_STEAM_ID, steam_id, 0);
  }
  void add_entity_id(uint64_t entity_id) {
    fbb_.AddElement<uint64_t>(NetMsg_ServerClientInfo::VT_ENTITY_ID, entity_id, 0);
  }
  explicit NetMsg_ServerClientInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NetMsg_ServerClientInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NetMsg_ServerClientInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NetMsg_ServerClientInfo> CreateNetMsg_ServerClientInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    uint64_t steam_id = 0,
    uint64_t entity_id = 0) {
  NetMsg_ServerClientInfoBuilder builder_(_fbb);
  builder_.add_entity_id(entity_id);
  builder_.add_steam_id(steam_id);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NetMsg_ServerClientInfo> CreateNetMsg_ServerClientInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint64_t steam_id = 0,
    uint64_t entity_id = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return CreateNetMsg_ServerClientInfo(
      _fbb,
      name__,
      steam_id,
      entity_id);
}

struct NetMsg_ServerConnectResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NetMsg_ServerConnectResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLIENT_ENTITY_ID = 4
  };
  uint64_t client_entity_id() const {
    return GetField<uint64_t>(VT_CLIENT_ENTITY_ID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_CLIENT_ENTITY_ID, 8) &&
           verifier.EndTable();
  }
};

struct NetMsg_ServerConnectResponseBuilder {
  typedef NetMsg_ServerConnectResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_client_entity_id(uint64_t client_entity_id) {
    fbb_.AddElement<uint64_t>(NetMsg_ServerConnectResponse::VT_CLIENT_ENTITY_ID, client_entity_id, 0);
  }
  explicit NetMsg_ServerConnectResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NetMsg_ServerConnectResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NetMsg_ServerConnectResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NetMsg_ServerConnectResponse> CreateNetMsg_ServerConnectResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t client_entity_id = 0) {
  NetMsg_ServerConnectResponseBuilder builder_(_fbb);
  builder_.add_client_entity_id(client_entity_id);
  return builder_.Finish();
}

struct NetMsg_ClientConnect FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NetMsg_ClientConnectBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PROTOCOL = 4
  };
  uint16_t protocol() const {
    return GetField<uint16_t>(VT_PROTOCOL, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_PROTOCOL, 2) &&
           verifier.EndTable();
  }
};

struct NetMsg_ClientConnectBuilder {
  typedef NetMsg_ClientConnect Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_protocol(uint16_t protocol) {
    fbb_.AddElement<uint16_t>(NetMsg_ClientConnect::VT_PROTOCOL, protocol, 0);
  }
  explicit NetMsg_ClientConnectBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NetMsg_ClientConnect> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NetMsg_ClientConnect>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NetMsg_ClientConnect> CreateNetMsg_ClientConnect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t protocol = 0) {
  NetMsg_ClientConnectBuilder builder_(_fbb);
  builder_.add_protocol(protocol);
  return builder_.Finish();
}

struct NetMsg_Disconnect FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NetMsg_DisconnectBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REASON = 4
  };
  const ::flatbuffers::String *reason() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REASON);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_REASON) &&
           verifier.VerifyString(reason()) &&
           verifier.EndTable();
  }
};

struct NetMsg_DisconnectBuilder {
  typedef NetMsg_Disconnect Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_reason(::flatbuffers::Offset<::flatbuffers::String> reason) {
    fbb_.AddOffset(NetMsg_Disconnect::VT_REASON, reason);
  }
  explicit NetMsg_DisconnectBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NetMsg_Disconnect> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NetMsg_Disconnect>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NetMsg_Disconnect> CreateNetMsg_Disconnect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> reason = 0) {
  NetMsg_DisconnectBuilder builder_(_fbb);
  builder_.add_reason(reason);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NetMsg_Disconnect> CreateNetMsg_DisconnectDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *reason = nullptr) {
  auto reason__ = reason ? _fbb.CreateString(reason) : 0;
  return CreateNetMsg_Disconnect(
      _fbb,
      reason__);
}

struct NetMsg_ConVar FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NetMsg_ConVarBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMAND = 4
  };
  const ::flatbuffers::String *command() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COMMAND);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMMAND) &&
           verifier.VerifyString(command()) &&
           verifier.EndTable();
  }
};

struct NetMsg_ConVarBuilder {
  typedef NetMsg_ConVar Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_command(::flatbuffers::Offset<::flatbuffers::String> command) {
    fbb_.AddOffset(NetMsg_ConVar::VT_COMMAND, command);
  }
  explicit NetMsg_ConVarBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NetMsg_ConVar> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NetMsg_ConVar>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NetMsg_ConVar> CreateNetMsg_ConVar(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> command = 0) {
  NetMsg_ConVarBuilder builder_(_fbb);
  builder_.add_command(command);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NetMsg_ConVar> CreateNetMsg_ConVarDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *command = nullptr) {
  auto command__ = command ? _fbb.CreateString(command) : 0;
  return CreateNetMsg_ConVar(
      _fbb,
      command__);
}

struct NetMsg_Paused FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NetMsg_PausedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PAUSED = 4
  };
  bool paused() const {
    return GetField<uint8_t>(VT_PAUSED, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PAUSED, 1) &&
           verifier.EndTable();
  }
};

struct NetMsg_PausedBuilder {
  typedef NetMsg_Paused Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_paused(bool paused) {
    fbb_.AddElement<uint8_t>(NetMsg_Paused::VT_PAUSED, static_cast<uint8_t>(paused), 0);
  }
  explicit NetMsg_PausedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NetMsg_Paused> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NetMsg_Paused>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NetMsg_Paused> CreateNetMsg_Paused(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool paused = false) {
  NetMsg_PausedBuilder builder_(_fbb);
  builder_.add_paused(paused);
  return builder_.Finish();
}

struct MsgSrc_Client FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MsgSrc_ClientBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_DATA = 6
  };
  EMsgSrc_Client type() const {
    return static_cast<EMsgSrc_Client>(GetField<uint8_t>(VT_TYPE, 0));
  }
  const ::flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct MsgSrc_ClientBuilder {
  typedef MsgSrc_Client Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type(EMsgSrc_Client type) {
    fbb_.AddElement<uint8_t>(MsgSrc_Client::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(MsgSrc_Client::VT_DATA, data);
  }
  explicit MsgSrc_ClientBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MsgSrc_Client> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MsgSrc_Client>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MsgSrc_Client> CreateMsgSrc_Client(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    EMsgSrc_Client type = EMsgSrc_Client_Invalid,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data = 0) {
  MsgSrc_ClientBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MsgSrc_Client> CreateMsgSrc_ClientDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    EMsgSrc_Client type = EMsgSrc_Client_Invalid,
    const std::vector<uint8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return CreateMsgSrc_Client(
      _fbb,
      type,
      data__);
}

struct MsgSrc_Server FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MsgSrc_ServerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_DATA = 6
  };
  EMsgSrc_Server type() const {
    return static_cast<EMsgSrc_Server>(GetField<uint8_t>(VT_TYPE, 0));
  }
  const ::flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct MsgSrc_ServerBuilder {
  typedef MsgSrc_Server Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type(EMsgSrc_Server type) {
    fbb_.AddElement<uint8_t>(MsgSrc_Server::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(MsgSrc_Server::VT_DATA, data);
  }
  explicit MsgSrc_ServerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MsgSrc_Server> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MsgSrc_Server>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MsgSrc_Server> CreateMsgSrc_Server(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    EMsgSrc_Server type = EMsgSrc_Server_Invalid,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data = 0) {
  MsgSrc_ServerBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MsgSrc_Server> CreateMsgSrc_ServerDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    EMsgSrc_Server type = EMsgSrc_Server_Invalid,
    const std::vector<uint8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return CreateMsgSrc_Server(
      _fbb,
      type,
      data__);
}

struct NetMsg_ComponentUpdateData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NetMsg_ComponentUpdateDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_VALUES = 6,
    VT_DESTROYED = 8
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *values() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_VALUES);
  }
  bool destroyed() const {
    return GetField<uint8_t>(VT_DESTROYED, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID, 4) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           VerifyField<uint8_t>(verifier, VT_DESTROYED, 1) &&
           verifier.EndTable();
  }
};

struct NetMsg_ComponentUpdateDataBuilder {
  typedef NetMsg_ComponentUpdateData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(NetMsg_ComponentUpdateData::VT_ID, id, 0);
  }
  void add_values(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> values) {
    fbb_.AddOffset(NetMsg_ComponentUpdateData::VT_VALUES, values);
  }
  void add_destroyed(bool destroyed) {
    fbb_.AddElement<uint8_t>(NetMsg_ComponentUpdateData::VT_DESTROYED, static_cast<uint8_t>(destroyed), 0);
  }
  explicit NetMsg_ComponentUpdateDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NetMsg_ComponentUpdateData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NetMsg_ComponentUpdateData>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NetMsg_ComponentUpdateData> CreateNetMsg_ComponentUpdateData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> values = 0,
    bool destroyed = false) {
  NetMsg_ComponentUpdateDataBuilder builder_(_fbb);
  builder_.add_values(values);
  builder_.add_id(id);
  builder_.add_destroyed(destroyed);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NetMsg_ComponentUpdateData> CreateNetMsg_ComponentUpdateDataDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    const std::vector<uint8_t> *values = nullptr,
    bool destroyed = false) {
  auto values__ = values ? _fbb.CreateVector<uint8_t>(*values) : 0;
  return CreateNetMsg_ComponentUpdateData(
      _fbb,
      id,
      values__,
      destroyed);
}

struct NetMsg_ComponentUpdate FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NetMsg_ComponentUpdateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_COMPONENTS = 6
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<NetMsg_ComponentUpdateData>> *components() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<NetMsg_ComponentUpdateData>> *>(VT_COMPONENTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_COMPONENTS) &&
           verifier.VerifyVector(components()) &&
           verifier.VerifyVectorOfTables(components()) &&
           verifier.EndTable();
  }
};

struct NetMsg_ComponentUpdateBuilder {
  typedef NetMsg_ComponentUpdate Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(NetMsg_ComponentUpdate::VT_NAME, name);
  }
  void add_components(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NetMsg_ComponentUpdateData>>> components) {
    fbb_.AddOffset(NetMsg_ComponentUpdate::VT_COMPONENTS, components);
  }
  explicit NetMsg_ComponentUpdateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NetMsg_ComponentUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NetMsg_ComponentUpdate>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NetMsg_ComponentUpdate> CreateNetMsg_ComponentUpdate(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NetMsg_ComponentUpdateData>>> components = 0) {
  NetMsg_ComponentUpdateBuilder builder_(_fbb);
  builder_.add_components(components);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NetMsg_ComponentUpdate> CreateNetMsg_ComponentUpdateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<::flatbuffers::Offset<NetMsg_ComponentUpdateData>> *components = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto components__ = components ? _fbb.CreateVector<::flatbuffers::Offset<NetMsg_ComponentUpdateData>>(*components) : 0;
  return CreateNetMsg_ComponentUpdate(
      _fbb,
      name__,
      components__);
}

struct NetMsg_EntityUpdate FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NetMsg_EntityUpdateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_DESTROYED = 6
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  bool destroyed() const {
    return GetField<uint8_t>(VT_DESTROYED, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID, 4) &&
           VerifyField<uint8_t>(verifier, VT_DESTROYED, 1) &&
           verifier.EndTable();
  }
};

struct NetMsg_EntityUpdateBuilder {
  typedef NetMsg_EntityUpdate Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(NetMsg_EntityUpdate::VT_ID, id, 0);
  }
  void add_destroyed(bool destroyed) {
    fbb_.AddElement<uint8_t>(NetMsg_EntityUpdate::VT_DESTROYED, static_cast<uint8_t>(destroyed), 0);
  }
  explicit NetMsg_EntityUpdateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NetMsg_EntityUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NetMsg_EntityUpdate>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NetMsg_EntityUpdate> CreateNetMsg_EntityUpdate(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    bool destroyed = false) {
  NetMsg_EntityUpdateBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_destroyed(destroyed);
  return builder_.Finish();
}

struct NetMsg_EntityUpdates FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NetMsg_EntityUpdatesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UPDATE_LIST = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<NetMsg_EntityUpdate>> *update_list() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<NetMsg_EntityUpdate>> *>(VT_UPDATE_LIST);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_UPDATE_LIST) &&
           verifier.VerifyVector(update_list()) &&
           verifier.VerifyVectorOfTables(update_list()) &&
           verifier.EndTable();
  }
};

struct NetMsg_EntityUpdatesBuilder {
  typedef NetMsg_EntityUpdates Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_update_list(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NetMsg_EntityUpdate>>> update_list) {
    fbb_.AddOffset(NetMsg_EntityUpdates::VT_UPDATE_LIST, update_list);
  }
  explicit NetMsg_EntityUpdatesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NetMsg_EntityUpdates> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NetMsg_EntityUpdates>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NetMsg_EntityUpdates> CreateNetMsg_EntityUpdates(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NetMsg_EntityUpdate>>> update_list = 0) {
  NetMsg_EntityUpdatesBuilder builder_(_fbb);
  builder_.add_update_list(update_list);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NetMsg_EntityUpdates> CreateNetMsg_EntityUpdatesDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<NetMsg_EntityUpdate>> *update_list = nullptr) {
  auto update_list__ = update_list ? _fbb.CreateVector<::flatbuffers::Offset<NetMsg_EntityUpdate>>(*update_list) : 0;
  return CreateNetMsg_EntityUpdates(
      _fbb,
      update_list__);
}

struct NetMsg_ComponentUpdates FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NetMsg_ComponentUpdatesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UPDATE_LIST = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<NetMsg_ComponentUpdate>> *update_list() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<NetMsg_ComponentUpdate>> *>(VT_UPDATE_LIST);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_UPDATE_LIST) &&
           verifier.VerifyVector(update_list()) &&
           verifier.VerifyVectorOfTables(update_list()) &&
           verifier.EndTable();
  }
};

struct NetMsg_ComponentUpdatesBuilder {
  typedef NetMsg_ComponentUpdates Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_update_list(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NetMsg_ComponentUpdate>>> update_list) {
    fbb_.AddOffset(NetMsg_ComponentUpdates::VT_UPDATE_LIST, update_list);
  }
  explicit NetMsg_ComponentUpdatesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NetMsg_ComponentUpdates> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NetMsg_ComponentUpdates>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NetMsg_ComponentUpdates> CreateNetMsg_ComponentUpdates(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NetMsg_ComponentUpdate>>> update_list = 0) {
  NetMsg_ComponentUpdatesBuilder builder_(_fbb);
  builder_.add_update_list(update_list);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NetMsg_ComponentUpdates> CreateNetMsg_ComponentUpdatesDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<NetMsg_ComponentUpdate>> *update_list = nullptr) {
  auto update_list__ = update_list ? _fbb.CreateVector<::flatbuffers::Offset<NetMsg_ComponentUpdate>>(*update_list) : 0;
  return CreateNetMsg_ComponentUpdates(
      _fbb,
      update_list__);
}

struct NetComp_Transform FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NetComp_TransformBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POS = 4,
    VT_ANG = 6,
    VT_SCALE = 8
  };
  const Vec3 *pos() const {
    return GetStruct<const Vec3 *>(VT_POS);
  }
  const Vec3 *ang() const {
    return GetStruct<const Vec3 *>(VT_ANG);
  }
  const Vec3 *scale() const {
    return GetStruct<const Vec3 *>(VT_SCALE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Vec3>(verifier, VT_POS, 4) &&
           VerifyField<Vec3>(verifier, VT_ANG, 4) &&
           VerifyField<Vec3>(verifier, VT_SCALE, 4) &&
           verifier.EndTable();
  }
};

struct NetComp_TransformBuilder {
  typedef NetComp_Transform Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pos(const Vec3 *pos) {
    fbb_.AddStruct(NetComp_Transform::VT_POS, pos);
  }
  void add_ang(const Vec3 *ang) {
    fbb_.AddStruct(NetComp_Transform::VT_ANG, ang);
  }
  void add_scale(const Vec3 *scale) {
    fbb_.AddStruct(NetComp_Transform::VT_SCALE, scale);
  }
  explicit NetComp_TransformBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NetComp_Transform> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NetComp_Transform>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NetComp_Transform> CreateNetComp_Transform(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const Vec3 *pos = nullptr,
    const Vec3 *ang = nullptr,
    const Vec3 *scale = nullptr) {
  NetComp_TransformBuilder builder_(_fbb);
  builder_.add_scale(scale);
  builder_.add_ang(ang);
  builder_.add_pos(pos);
  return builder_.Finish();
}

struct NetComp_TransformSmall FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NetComp_TransformSmallBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POS = 4,
    VT_ANG = 6
  };
  const Vec3 *pos() const {
    return GetStruct<const Vec3 *>(VT_POS);
  }
  const Vec3 *ang() const {
    return GetStruct<const Vec3 *>(VT_ANG);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Vec3>(verifier, VT_POS, 4) &&
           VerifyField<Vec3>(verifier, VT_ANG, 4) &&
           verifier.EndTable();
  }
};

struct NetComp_TransformSmallBuilder {
  typedef NetComp_TransformSmall Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pos(const Vec3 *pos) {
    fbb_.AddStruct(NetComp_TransformSmall::VT_POS, pos);
  }
  void add_ang(const Vec3 *ang) {
    fbb_.AddStruct(NetComp_TransformSmall::VT_ANG, ang);
  }
  explicit NetComp_TransformSmallBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NetComp_TransformSmall> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NetComp_TransformSmall>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NetComp_TransformSmall> CreateNetComp_TransformSmall(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const Vec3 *pos = nullptr,
    const Vec3 *ang = nullptr) {
  NetComp_TransformSmallBuilder builder_(_fbb);
  builder_.add_ang(ang);
  builder_.add_pos(pos);
  return builder_.Finish();
}

struct NetComp_RigidBody FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NetComp_RigidBodyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VEL = 4,
    VT_ACCEL = 6
  };
  const Vec3 *vel() const {
    return GetStruct<const Vec3 *>(VT_VEL);
  }
  const Vec3 *accel() const {
    return GetStruct<const Vec3 *>(VT_ACCEL);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Vec3>(verifier, VT_VEL, 4) &&
           VerifyField<Vec3>(verifier, VT_ACCEL, 4) &&
           verifier.EndTable();
  }
};

struct NetComp_RigidBodyBuilder {
  typedef NetComp_RigidBody Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_vel(const Vec3 *vel) {
    fbb_.AddStruct(NetComp_RigidBody::VT_VEL, vel);
  }
  void add_accel(const Vec3 *accel) {
    fbb_.AddStruct(NetComp_RigidBody::VT_ACCEL, accel);
  }
  explicit NetComp_RigidBodyBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NetComp_RigidBody> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NetComp_RigidBody>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NetComp_RigidBody> CreateNetComp_RigidBody(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const Vec3 *vel = nullptr,
    const Vec3 *accel = nullptr) {
  NetComp_RigidBodyBuilder builder_(_fbb);
  builder_.add_accel(accel);
  builder_.add_vel(vel);
  return builder_.Finish();
}

struct NetComp_Direction FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NetComp_DirectionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORWARD = 4,
    VT_UP = 6,
    VT_RIGHT = 8
  };
  const Vec3 *forward() const {
    return GetStruct<const Vec3 *>(VT_FORWARD);
  }
  const Vec3 *up() const {
    return GetStruct<const Vec3 *>(VT_UP);
  }
  const Vec3 *right() const {
    return GetStruct<const Vec3 *>(VT_RIGHT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Vec3>(verifier, VT_FORWARD, 4) &&
           VerifyField<Vec3>(verifier, VT_UP, 4) &&
           VerifyField<Vec3>(verifier, VT_RIGHT, 4) &&
           verifier.EndTable();
  }
};

struct NetComp_DirectionBuilder {
  typedef NetComp_Direction Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_forward(const Vec3 *forward) {
    fbb_.AddStruct(NetComp_Direction::VT_FORWARD, forward);
  }
  void add_up(const Vec3 *up) {
    fbb_.AddStruct(NetComp_Direction::VT_UP, up);
  }
  void add_right(const Vec3 *right) {
    fbb_.AddStruct(NetComp_Direction::VT_RIGHT, right);
  }
  explicit NetComp_DirectionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NetComp_Direction> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NetComp_Direction>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NetComp_Direction> CreateNetComp_Direction(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const Vec3 *forward = nullptr,
    const Vec3 *up = nullptr,
    const Vec3 *right = nullptr) {
  NetComp_DirectionBuilder builder_(_fbb);
  builder_.add_right(right);
  builder_.add_up(up);
  builder_.add_forward(forward);
  return builder_.Finish();
}

struct NetComp_Gravity FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NetComp_GravityBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORCE = 4
  };
  const Vec3 *force() const {
    return GetStruct<const Vec3 *>(VT_FORCE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Vec3>(verifier, VT_FORCE, 4) &&
           verifier.EndTable();
  }
};

struct NetComp_GravityBuilder {
  typedef NetComp_Gravity Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_force(const Vec3 *force) {
    fbb_.AddStruct(NetComp_Gravity::VT_FORCE, force);
  }
  explicit NetComp_GravityBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NetComp_Gravity> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NetComp_Gravity>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NetComp_Gravity> CreateNetComp_Gravity(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const Vec3 *force = nullptr) {
  NetComp_GravityBuilder builder_(_fbb);
  builder_.add_force(force);
  return builder_.Finish();
}

struct NetComp_Camera FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NetComp_CameraBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIRECTION = 4,
    VT_TRANSFORM = 6,
    VT_FOV = 8
  };
  const NetComp_Direction *direction() const {
    return GetPointer<const NetComp_Direction *>(VT_DIRECTION);
  }
  const NetComp_TransformSmall *transform() const {
    return GetPointer<const NetComp_TransformSmall *>(VT_TRANSFORM);
  }
  float fov() const {
    return GetField<float>(VT_FOV, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DIRECTION) &&
           verifier.VerifyTable(direction()) &&
           VerifyOffset(verifier, VT_TRANSFORM) &&
           verifier.VerifyTable(transform()) &&
           VerifyField<float>(verifier, VT_FOV, 4) &&
           verifier.EndTable();
  }
};

struct NetComp_CameraBuilder {
  typedef NetComp_Camera Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_direction(::flatbuffers::Offset<NetComp_Direction> direction) {
    fbb_.AddOffset(NetComp_Camera::VT_DIRECTION, direction);
  }
  void add_transform(::flatbuffers::Offset<NetComp_TransformSmall> transform) {
    fbb_.AddOffset(NetComp_Camera::VT_TRANSFORM, transform);
  }
  void add_fov(float fov) {
    fbb_.AddElement<float>(NetComp_Camera::VT_FOV, fov, 0.0f);
  }
  explicit NetComp_CameraBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NetComp_Camera> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NetComp_Camera>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NetComp_Camera> CreateNetComp_Camera(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<NetComp_Direction> direction = 0,
    ::flatbuffers::Offset<NetComp_TransformSmall> transform = 0,
    float fov = 0.0f) {
  NetComp_CameraBuilder builder_(_fbb);
  builder_.add_fov(fov);
  builder_.add_transform(transform);
  builder_.add_direction(direction);
  return builder_.Finish();
}

struct NetComp_ModelInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NetComp_ModelInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PATH = 4
  };
  const ::flatbuffers::String *path() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PATH);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PATH) &&
           verifier.VerifyString(path()) &&
           verifier.EndTable();
  }
};

struct NetComp_ModelInfoBuilder {
  typedef NetComp_ModelInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_path(::flatbuffers::Offset<::flatbuffers::String> path) {
    fbb_.AddOffset(NetComp_ModelInfo::VT_PATH, path);
  }
  explicit NetComp_ModelInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NetComp_ModelInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NetComp_ModelInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NetComp_ModelInfo> CreateNetComp_ModelInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> path = 0) {
  NetComp_ModelInfoBuilder builder_(_fbb);
  builder_.add_path(path);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NetComp_ModelInfo> CreateNetComp_ModelInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *path = nullptr) {
  auto path__ = path ? _fbb.CreateString(path) : 0;
  return CreateNetComp_ModelInfo(
      _fbb,
      path__);
}

struct NetComp_Light FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NetComp_LightBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_COLOR = 6,
    VT_POS = 8,
    VT_ANG = 10,
    VT_INNERFOV = 12,
    VT_OUTERFOV = 14,
    VT_RADIUS = 16,
    VT_LENGTH = 18,
    VT_SHADOW = 20,
    VT_ENABLED = 22
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  const Vec4 *color() const {
    return GetStruct<const Vec4 *>(VT_COLOR);
  }
  const Vec3 *pos() const {
    return GetStruct<const Vec3 *>(VT_POS);
  }
  const Vec3 *ang() const {
    return GetStruct<const Vec3 *>(VT_ANG);
  }
  float innerFov() const {
    return GetField<float>(VT_INNERFOV, 0.0f);
  }
  float outerFov() const {
    return GetField<float>(VT_OUTERFOV, 0.0f);
  }
  float radius() const {
    return GetField<float>(VT_RADIUS, 0.0f);
  }
  float length() const {
    return GetField<float>(VT_LENGTH, 0.0f);
  }
  bool shadow() const {
    return GetField<uint8_t>(VT_SHADOW, 0) != 0;
  }
  bool enabled() const {
    return GetField<uint8_t>(VT_ENABLED, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE, 4) &&
           VerifyField<Vec4>(verifier, VT_COLOR, 4) &&
           VerifyField<Vec3>(verifier, VT_POS, 4) &&
           VerifyField<Vec3>(verifier, VT_ANG, 4) &&
           VerifyField<float>(verifier, VT_INNERFOV, 4) &&
           VerifyField<float>(verifier, VT_OUTERFOV, 4) &&
           VerifyField<float>(verifier, VT_RADIUS, 4) &&
           VerifyField<float>(verifier, VT_LENGTH, 4) &&
           VerifyField<uint8_t>(verifier, VT_SHADOW, 1) &&
           VerifyField<uint8_t>(verifier, VT_ENABLED, 1) &&
           verifier.EndTable();
  }
};

struct NetComp_LightBuilder {
  typedef NetComp_Light Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(NetComp_Light::VT_TYPE, type, 0);
  }
  void add_color(const Vec4 *color) {
    fbb_.AddStruct(NetComp_Light::VT_COLOR, color);
  }
  void add_pos(const Vec3 *pos) {
    fbb_.AddStruct(NetComp_Light::VT_POS, pos);
  }
  void add_ang(const Vec3 *ang) {
    fbb_.AddStruct(NetComp_Light::VT_ANG, ang);
  }
  void add_innerFov(float innerFov) {
    fbb_.AddElement<float>(NetComp_Light::VT_INNERFOV, innerFov, 0.0f);
  }
  void add_outerFov(float outerFov) {
    fbb_.AddElement<float>(NetComp_Light::VT_OUTERFOV, outerFov, 0.0f);
  }
  void add_radius(float radius) {
    fbb_.AddElement<float>(NetComp_Light::VT_RADIUS, radius, 0.0f);
  }
  void add_length(float length) {
    fbb_.AddElement<float>(NetComp_Light::VT_LENGTH, length, 0.0f);
  }
  void add_shadow(bool shadow) {
    fbb_.AddElement<uint8_t>(NetComp_Light::VT_SHADOW, static_cast<uint8_t>(shadow), 0);
  }
  void add_enabled(bool enabled) {
    fbb_.AddElement<uint8_t>(NetComp_Light::VT_ENABLED, static_cast<uint8_t>(enabled), 0);
  }
  explicit NetComp_LightBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NetComp_Light> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NetComp_Light>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NetComp_Light> CreateNetComp_Light(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 0,
    const Vec4 *color = nullptr,
    const Vec3 *pos = nullptr,
    const Vec3 *ang = nullptr,
    float innerFov = 0.0f,
    float outerFov = 0.0f,
    float radius = 0.0f,
    float length = 0.0f,
    bool shadow = false,
    bool enabled = false) {
  NetComp_LightBuilder builder_(_fbb);
  builder_.add_length(length);
  builder_.add_radius(radius);
  builder_.add_outerFov(outerFov);
  builder_.add_innerFov(innerFov);
  builder_.add_ang(ang);
  builder_.add_pos(pos);
  builder_.add_color(color);
  builder_.add_type(type);
  builder_.add_enabled(enabled);
  builder_.add_shadow(shadow);
  return builder_.Finish();
}

struct NetComp_PlayerMoveData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NetComp_PlayerMoveDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MOVETYPE = 4,
    VT_PLAYERFLAGS = 6,
    VT_PREVPLAYERFLAGS = 8,
    VT_MAXSPEED = 10,
    VT_WALKTIME = 12,
    VT_BOBOFFSETAMOUNT = 14,
    VT_PREVVIEWTILT = 16,
    VT_LANDPOWER = 18,
    VT_LANDTIME = 20,
    VT_PREVVIEWHEIGHT = 22,
    VT_TARGETVIEWHEIGHT = 24,
    VT_OUTVIEWHEIGHT = 26,
    VT_DUCKDURATION = 28,
    VT_DUCKTIME = 30
  };
  EPlayerMoveType moveType() const {
    return static_cast<EPlayerMoveType>(GetField<int8_t>(VT_MOVETYPE, 0));
  }
  uint8_t playerFlags() const {
    return GetField<uint8_t>(VT_PLAYERFLAGS, 0);
  }
  uint8_t prevPlayerFlags() const {
    return GetField<uint8_t>(VT_PREVPLAYERFLAGS, 0);
  }
  float maxSpeed() const {
    return GetField<float>(VT_MAXSPEED, 0.0f);
  }
  float walkTime() const {
    return GetField<float>(VT_WALKTIME, 0.0f);
  }
  float bobOffsetAmount() const {
    return GetField<float>(VT_BOBOFFSETAMOUNT, 0.0f);
  }
  float prevViewTilt() const {
    return GetField<float>(VT_PREVVIEWTILT, 0.0f);
  }
  float landPower() const {
    return GetField<float>(VT_LANDPOWER, 0.0f);
  }
  float landTime() const {
    return GetField<float>(VT_LANDTIME, 0.0f);
  }
  float prevViewHeight() const {
    return GetField<float>(VT_PREVVIEWHEIGHT, 0.0f);
  }
  float targetViewHeight() const {
    return GetField<float>(VT_TARGETVIEWHEIGHT, 0.0f);
  }
  float outViewHeight() const {
    return GetField<float>(VT_OUTVIEWHEIGHT, 0.0f);
  }
  float duckDuration() const {
    return GetField<float>(VT_DUCKDURATION, 0.0f);
  }
  float duckTime() const {
    return GetField<float>(VT_DUCKTIME, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_MOVETYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_PLAYERFLAGS, 1) &&
           VerifyField<uint8_t>(verifier, VT_PREVPLAYERFLAGS, 1) &&
           VerifyField<float>(verifier, VT_MAXSPEED, 4) &&
           VerifyField<float>(verifier, VT_WALKTIME, 4) &&
           VerifyField<float>(verifier, VT_BOBOFFSETAMOUNT, 4) &&
           VerifyField<float>(verifier, VT_PREVVIEWTILT, 4) &&
           VerifyField<float>(verifier, VT_LANDPOWER, 4) &&
           VerifyField<float>(verifier, VT_LANDTIME, 4) &&
           VerifyField<float>(verifier, VT_PREVVIEWHEIGHT, 4) &&
           VerifyField<float>(verifier, VT_TARGETVIEWHEIGHT, 4) &&
           VerifyField<float>(verifier, VT_OUTVIEWHEIGHT, 4) &&
           VerifyField<float>(verifier, VT_DUCKDURATION, 4) &&
           VerifyField<float>(verifier, VT_DUCKTIME, 4) &&
           verifier.EndTable();
  }
};

struct NetComp_PlayerMoveDataBuilder {
  typedef NetComp_PlayerMoveData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_moveType(EPlayerMoveType moveType) {
    fbb_.AddElement<int8_t>(NetComp_PlayerMoveData::VT_MOVETYPE, static_cast<int8_t>(moveType), 0);
  }
  void add_playerFlags(uint8_t playerFlags) {
    fbb_.AddElement<uint8_t>(NetComp_PlayerMoveData::VT_PLAYERFLAGS, playerFlags, 0);
  }
  void add_prevPlayerFlags(uint8_t prevPlayerFlags) {
    fbb_.AddElement<uint8_t>(NetComp_PlayerMoveData::VT_PREVPLAYERFLAGS, prevPlayerFlags, 0);
  }
  void add_maxSpeed(float maxSpeed) {
    fbb_.AddElement<float>(NetComp_PlayerMoveData::VT_MAXSPEED, maxSpeed, 0.0f);
  }
  void add_walkTime(float walkTime) {
    fbb_.AddElement<float>(NetComp_PlayerMoveData::VT_WALKTIME, walkTime, 0.0f);
  }
  void add_bobOffsetAmount(float bobOffsetAmount) {
    fbb_.AddElement<float>(NetComp_PlayerMoveData::VT_BOBOFFSETAMOUNT, bobOffsetAmount, 0.0f);
  }
  void add_prevViewTilt(float prevViewTilt) {
    fbb_.AddElement<float>(NetComp_PlayerMoveData::VT_PREVVIEWTILT, prevViewTilt, 0.0f);
  }
  void add_landPower(float landPower) {
    fbb_.AddElement<float>(NetComp_PlayerMoveData::VT_LANDPOWER, landPower, 0.0f);
  }
  void add_landTime(float landTime) {
    fbb_.AddElement<float>(NetComp_PlayerMoveData::VT_LANDTIME, landTime, 0.0f);
  }
  void add_prevViewHeight(float prevViewHeight) {
    fbb_.AddElement<float>(NetComp_PlayerMoveData::VT_PREVVIEWHEIGHT, prevViewHeight, 0.0f);
  }
  void add_targetViewHeight(float targetViewHeight) {
    fbb_.AddElement<float>(NetComp_PlayerMoveData::VT_TARGETVIEWHEIGHT, targetViewHeight, 0.0f);
  }
  void add_outViewHeight(float outViewHeight) {
    fbb_.AddElement<float>(NetComp_PlayerMoveData::VT_OUTVIEWHEIGHT, outViewHeight, 0.0f);
  }
  void add_duckDuration(float duckDuration) {
    fbb_.AddElement<float>(NetComp_PlayerMoveData::VT_DUCKDURATION, duckDuration, 0.0f);
  }
  void add_duckTime(float duckTime) {
    fbb_.AddElement<float>(NetComp_PlayerMoveData::VT_DUCKTIME, duckTime, 0.0f);
  }
  explicit NetComp_PlayerMoveDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NetComp_PlayerMoveData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NetComp_PlayerMoveData>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NetComp_PlayerMoveData> CreateNetComp_PlayerMoveData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    EPlayerMoveType moveType = EPlayerMoveType_Walk,
    uint8_t playerFlags = 0,
    uint8_t prevPlayerFlags = 0,
    float maxSpeed = 0.0f,
    float walkTime = 0.0f,
    float bobOffsetAmount = 0.0f,
    float prevViewTilt = 0.0f,
    float landPower = 0.0f,
    float landTime = 0.0f,
    float prevViewHeight = 0.0f,
    float targetViewHeight = 0.0f,
    float outViewHeight = 0.0f,
    float duckDuration = 0.0f,
    float duckTime = 0.0f) {
  NetComp_PlayerMoveDataBuilder builder_(_fbb);
  builder_.add_duckTime(duckTime);
  builder_.add_duckDuration(duckDuration);
  builder_.add_outViewHeight(outViewHeight);
  builder_.add_targetViewHeight(targetViewHeight);
  builder_.add_prevViewHeight(prevViewHeight);
  builder_.add_landTime(landTime);
  builder_.add_landPower(landPower);
  builder_.add_prevViewTilt(prevViewTilt);
  builder_.add_bobOffsetAmount(bobOffsetAmount);
  builder_.add_walkTime(walkTime);
  builder_.add_maxSpeed(maxSpeed);
  builder_.add_prevPlayerFlags(prevPlayerFlags);
  builder_.add_playerFlags(playerFlags);
  builder_.add_moveType(moveType);
  return builder_.Finish();
}

struct NetComp_PlayerZoom FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NetComp_PlayerZoomBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ORIGFOV = 4,
    VT_NEWFOV = 6
  };
  float origFov() const {
    return GetField<float>(VT_ORIGFOV, 0.0f);
  }
  float newFov() const {
    return GetField<float>(VT_NEWFOV, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_ORIGFOV, 4) &&
           VerifyField<float>(verifier, VT_NEWFOV, 4) &&
           verifier.EndTable();
  }
};

struct NetComp_PlayerZoomBuilder {
  typedef NetComp_PlayerZoom Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_origFov(float origFov) {
    fbb_.AddElement<float>(NetComp_PlayerZoom::VT_ORIGFOV, origFov, 0.0f);
  }
  void add_newFov(float newFov) {
    fbb_.AddElement<float>(NetComp_PlayerZoom::VT_NEWFOV, newFov, 0.0f);
  }
  explicit NetComp_PlayerZoomBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NetComp_PlayerZoom> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NetComp_PlayerZoom>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NetComp_PlayerZoom> CreateNetComp_PlayerZoom(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float origFov = 0.0f,
    float newFov = 0.0f) {
  NetComp_PlayerZoomBuilder builder_(_fbb);
  builder_.add_newFov(newFov);
  builder_.add_origFov(origFov);
  return builder_.Finish();
}

inline const NetMsg_ComponentUpdates *GetNetMsg_ComponentUpdates(const void *buf) {
  return ::flatbuffers::GetRoot<NetMsg_ComponentUpdates>(buf);
}

inline const NetMsg_ComponentUpdates *GetSizePrefixedNetMsg_ComponentUpdates(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<NetMsg_ComponentUpdates>(buf);
}

inline bool VerifyNetMsg_ComponentUpdatesBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<NetMsg_ComponentUpdates>(nullptr);
}

inline bool VerifySizePrefixedNetMsg_ComponentUpdatesBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<NetMsg_ComponentUpdates>(nullptr);
}

inline void FinishNetMsg_ComponentUpdatesBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<NetMsg_ComponentUpdates> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedNetMsg_ComponentUpdatesBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<NetMsg_ComponentUpdates> root) {
  fbb.FinishSizePrefixed(root);
}

#endif  // FLATBUFFERS_GENERATED_SIDURY_H_
