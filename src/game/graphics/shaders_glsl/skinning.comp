#version 450
#extension GL_EXT_nonuniform_qualifier : enable


#define CH_COMP_SHADER 1

#include "core.glsl"
#include "common_shadow.glsl"

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;


layout(push_constant) uniform SkinningParams {
	// uint aRenderableCount;

	uint aRenderable;
	uint aSourceVertexBuffer;
	uint aVertexCount;
	uint aBlendShapeCount;
}
push;


struct RenderableData_t
{
	uint aRenderable;
	uint aSourceVertexBuffer;
	uint aVertexCount;
	uint aBlendShapeCount;
};


// TODO: pack this for alignment
struct BoneTransform_t
{
	vec3 aPos;
	vec3 aRot;
	vec3 aScale;
};


// -----------------------------------------------------------------------------------
// Blend Shape Data


layout(set = 1, binding = 0) buffer restrict readonly Buffer_BlendShapeWeights {
	float data[];
}
gBlendShapeWeights;


layout(set = 1, binding = 1) buffer restrict readonly Buffer_BlendShapeData {
	VertexData_t vertices[];
}
gBlendShapeData;


// -----------------------------------------------------------------------------------


void main()
{
    // get current element shader is using
    uint vertIndex = gl_GlobalInvocationID.x;

	Renderable_t renderable = gCore.aRenderables[ push.aRenderable ];
	VertexData_t vert = gVertexBuffers[ push.aSourceVertexBuffer ].aVert[ vertIndex ];

	vec3 inPos  = vert.aPosNormX.xyz;
	vec3 inNorm = vec3(vert.aPosNormX.w, vert.aNormYZ_UV.xy);
	vec2 inUV   = vert.aNormYZ_UV.zw;

	vec3 newPos    = inPos;
	vec3 morphPos  = gBlendShapeData.vertices[ vertIndex ].aPosNormX.xyz;

	newPos += (1.f * morphPos);

	gVertexBuffers[ renderable.aVertexBuffer ].aVert[ vertIndex ].aPosNormX.xyz = newPos;
}

